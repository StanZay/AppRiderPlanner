import {
  band,
  linear,
  log,
  ordinal,
  point,
  pow,
  sequential,
  sqrt,
  threshold,
  time,
  utcTime
} from "./chunk-5L5DMF53.js";
import {
  useTheme
} from "./chunk-VKCM4YSD.js";
import {
  init_useId,
  useId
} from "./chunk-73CETHI6.js";
import {
  require_prop_types
} from "./chunk-7TYQWO6A.js";
import {
  _extends,
  init_extends
} from "./chunk-TRLI7EVB.js";
import {
  require_jsx_runtime
} from "./chunk-NRBATONI.js";
import {
  require_react
} from "./chunk-QJTFJ6OV.js";
import {
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/@mui/x-charts/esm/hooks/useDrawingArea.js
var React3 = __toESM(require_react());

// node_modules/@mui/x-charts/esm/context/DrawingProvider.js
init_extends();
var React2 = __toESM(require_react());
init_useId();

// node_modules/@mui/x-charts/esm/hooks/useChartDimensions.js
init_extends();
var React = __toESM(require_react());

// node_modules/@mui/x-charts/esm/constants.js
var DEFAULT_X_AXIS_KEY = "DEFAULT_X_AXIS_KEY";
var DEFAULT_Y_AXIS_KEY = "DEFAULT_Y_AXIS_KEY";
var DEFAULT_MARGINS = {
  top: 50,
  bottom: 50,
  left: 50,
  right: 50
};

// node_modules/@mui/x-charts/esm/hooks/useChartDimensions.js
var useChartDimensions = (width, height, margin) => {
  const defaultizedMargin = _extends({}, DEFAULT_MARGINS, margin);
  const drawingArea = React.useMemo(() => ({
    left: defaultizedMargin.left,
    top: defaultizedMargin.top,
    right: defaultizedMargin.right,
    bottom: defaultizedMargin.bottom,
    width: Math.max(0, width - defaultizedMargin.left - defaultizedMargin.right),
    height: Math.max(0, height - defaultizedMargin.top - defaultizedMargin.bottom)
  }), [width, height, defaultizedMargin.top, defaultizedMargin.bottom, defaultizedMargin.left, defaultizedMargin.right]);
  return drawingArea;
};
var useChartDimensions_default = useChartDimensions;

// node_modules/@mui/x-charts/esm/context/DrawingProvider.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var DrawingContext = React2.createContext({
  top: 0,
  left: 0,
  bottom: 0,
  right: 0,
  height: 300,
  width: 400,
  chartId: "",
  isPointInside: () => false
});
if (true) {
  DrawingContext.displayName = "DrawingContext";
}
var SvgContext = React2.createContext({
  isInitialized: false,
  data: {
    current: null
  }
});
if (true) {
  SvgContext.displayName = "SvgContext";
}
function DrawingProvider(props) {
  const {
    width,
    height,
    margin,
    svgRef,
    children
  } = props;
  const drawingArea = useChartDimensions_default(width, height, margin);
  const chartId = useId();
  const isPointInside = React2.useCallback(({
    x,
    y
  }, targetElement) => {
    if (targetElement && targetElement.closest("[data-drawing-container]")) {
      return true;
    }
    return x >= drawingArea.left && x <= drawingArea.left + drawingArea.width && y >= drawingArea.top && y <= drawingArea.top + drawingArea.height;
  }, [drawingArea]);
  const value = React2.useMemo(() => _extends({
    chartId: chartId ?? ""
  }, drawingArea, {
    isPointInside
  }), [chartId, drawingArea, isPointInside]);
  const refValue = React2.useMemo(() => ({
    isInitialized: true,
    data: svgRef
  }), [svgRef]);
  return (0, import_jsx_runtime.jsx)(SvgContext.Provider, {
    value: refValue,
    children: (0, import_jsx_runtime.jsx)(DrawingContext.Provider, {
      value,
      children
    })
  });
}

// node_modules/@mui/x-charts/esm/hooks/useDrawingArea.js
function useDrawingArea() {
  const {
    left,
    top,
    width,
    height,
    bottom,
    right,
    isPointInside
  } = React3.useContext(DrawingContext);
  return React3.useMemo(() => ({
    left,
    top,
    width,
    height,
    bottom,
    right,
    isPointInside
  }), [height, left, top, width, bottom, right, isPointInside]);
}

// node_modules/@mui/x-charts/esm/hooks/useChartId.js
var React4 = __toESM(require_react());
function useChartId() {
  const {
    chartId
  } = React4.useContext(DrawingContext);
  return React4.useMemo(() => chartId, [chartId]);
}

// node_modules/@mui/x-charts/esm/internals/isBandScale.js
function isBandScale(scale) {
  return scale.bandwidth !== void 0;
}

// node_modules/@mui/x-charts/esm/context/CartesianProvider/computeValue.js
init_extends();

// node_modules/@mui/x-charts/esm/models/axis.js
function isBandScaleConfig(scaleConfig) {
  return scaleConfig.scaleType === "band";
}
function isPointScaleConfig(scaleConfig) {
  return scaleConfig.scaleType === "point";
}

// node_modules/@mui/x-charts/esm/internals/colorScale.js
function getSequentialColorScale(config) {
  if (config.type === "piecewise") {
    return threshold(config.thresholds, config.colors);
  }
  return sequential([config.min ?? 0, config.max ?? 100], config.color);
}
function getOrdinalColorScale(config) {
  if (config.values) {
    return ordinal(config.values, config.colors).unknown(config.unknownColor ?? null);
  }
  return ordinal(config.colors.map((_, index) => index), config.colors).unknown(config.unknownColor ?? null);
}
function getColorScale(config) {
  return config.type === "ordinal" ? getOrdinalColorScale(config) : getSequentialColorScale(config);
}

// node_modules/@mui/x-charts/esm/hooks/useTicks.js
var React5 = __toESM(require_react());
function getTickNumber(params) {
  const {
    tickMaxStep,
    tickMinStep,
    tickNumber,
    range,
    domain
  } = params;
  const maxTicks = tickMinStep === void 0 ? 999 : Math.floor(Math.abs(domain[1] - domain[0]) / tickMinStep);
  const minTicks = tickMaxStep === void 0 ? 2 : Math.ceil(Math.abs(domain[1] - domain[0]) / tickMaxStep);
  const defaultizedTickNumber = tickNumber ?? Math.floor(Math.abs(range[1] - range[0]) / 50);
  return Math.min(maxTicks, Math.max(minTicks, defaultizedTickNumber));
}
var offsetRatio = {
  start: 0,
  extremities: 0,
  end: 1,
  middle: 0.5
};
function useTicks(options) {
  const {
    scale,
    tickNumber,
    valueFormatter,
    tickInterval,
    tickPlacement = "extremities",
    tickLabelPlacement = "middle"
  } = options;
  return React5.useMemo(() => {
    if (isBandScale(scale)) {
      const domain = scale.domain();
      if (scale.bandwidth() > 0) {
        const filteredDomain2 = typeof tickInterval === "function" && domain.filter(tickInterval) || typeof tickInterval === "object" && tickInterval || domain;
        return [...filteredDomain2.map((value) => ({
          value,
          formattedValue: (valueFormatter == null ? void 0 : valueFormatter(value, {
            location: "tick"
          })) ?? `${value}`,
          offset: scale(value) - (scale.step() - scale.bandwidth()) / 2 + offsetRatio[tickPlacement] * scale.step(),
          labelOffset: tickLabelPlacement === "tick" ? 0 : scale.step() * (offsetRatio[tickLabelPlacement] - offsetRatio[tickPlacement])
        })), ...tickPlacement === "extremities" ? [{
          formattedValue: void 0,
          offset: scale.range()[1],
          labelOffset: 0
        }] : []];
      }
      const filteredDomain = typeof tickInterval === "function" && domain.filter(tickInterval) || typeof tickInterval === "object" && tickInterval || domain;
      return filteredDomain.map((value) => ({
        value,
        formattedValue: (valueFormatter == null ? void 0 : valueFormatter(value, {
          location: "tick"
        })) ?? `${value}`,
        offset: scale(value),
        labelOffset: 0
      }));
    }
    if (scale.domain().length === 0 || scale.domain()[0] === scale.domain()[1]) {
      return [];
    }
    const ticks = typeof tickInterval === "object" ? tickInterval : scale.ticks(tickNumber);
    return ticks.map((value) => ({
      value,
      formattedValue: (valueFormatter == null ? void 0 : valueFormatter(value, {
        location: "tick"
      })) ?? scale.tickFormat(tickNumber)(value),
      offset: scale(value),
      labelOffset: 0
    }));
  }, [scale, tickInterval, tickNumber, valueFormatter, tickPlacement, tickLabelPlacement]);
}

// node_modules/@mui/x-charts/esm/internals/getScale.js
function getScale(scaleType, domain, range) {
  switch (scaleType) {
    case "log":
      return log(domain, range);
    case "pow":
      return pow(domain, range);
    case "sqrt":
      return sqrt(domain, range);
    case "time":
      return time(domain, range);
    case "utc":
      return utcTime(domain, range);
    default:
      return linear(domain, range);
  }
}

// node_modules/@mui/x-charts/esm/context/CartesianProvider/getAxisExtremum.js
var axisExtremumCallback = (acc, chartType, axis, getters, isDefaultAxis, formattedSeries) => {
  var _a;
  const getter = getters[chartType];
  const series = ((_a = formattedSeries[chartType]) == null ? void 0 : _a.series) ?? {};
  const [minChartTypeData, maxChartTypeData] = (getter == null ? void 0 : getter({
    series,
    axis,
    isDefaultAxis
  })) ?? [null, null];
  const [minData, maxData] = acc;
  if (minData === null || maxData === null) {
    return [minChartTypeData, maxChartTypeData];
  }
  if (minChartTypeData === null || maxChartTypeData === null) {
    return [minData, maxData];
  }
  return [Math.min(minChartTypeData, minData), Math.max(maxChartTypeData, maxData)];
};
var getAxisExtremum = (axis, getters, isDefaultAxis, formattedSeries) => {
  const charTypes = Object.keys(getters);
  return charTypes.reduce((acc, charType) => axisExtremumCallback(acc, charType, axis, getters, isDefaultAxis, formattedSeries), [null, null]);
};

// node_modules/@mui/x-charts/esm/context/CartesianProvider/normalizeAxis.js
init_extends();
var normalizeAxis = (axis, dataset, axisName) => {
  return (axis == null ? void 0 : axis.map((axisConfig) => {
    const dataKey = axisConfig.dataKey;
    if (dataKey === void 0 || axisConfig.data !== void 0) {
      return axisConfig;
    }
    if (dataset === void 0) {
      throw Error(`MUI X: ${axisName}-axis uses \`dataKey\` but no \`dataset\` is provided.`);
    }
    return _extends({}, axisConfig, {
      data: dataset.map((d) => d[dataKey])
    });
  })) ?? [];
};

// node_modules/@mui/x-charts/esm/context/CartesianProvider/computeValue.js
var getRange = (drawingArea, axisDirection, isReverse) => {
  const range = axisDirection === "x" ? [drawingArea.left, drawingArea.left + drawingArea.width] : [drawingArea.top + drawingArea.height, drawingArea.top];
  return isReverse ? range.reverse() : range;
};
var zoomedScaleRange = (scaleRange, zoomRange) => {
  const rangeGap = scaleRange[1] - scaleRange[0];
  const zoomGap = zoomRange[1] - zoomRange[0];
  const min = scaleRange[0] - zoomRange[0] * rangeGap / zoomGap;
  const max = scaleRange[1] + (100 - zoomRange[1]) * rangeGap / zoomGap;
  return [min, max];
};
var isDateData = (data) => (data == null ? void 0 : data[0]) instanceof Date;
function createDateFormatter(axis, range) {
  const timeScale = time(axis.data, range);
  return (v, {
    location
  }) => location === "tick" ? timeScale.tickFormat(axis.tickNumber)(v) : `${v.toLocaleString()}`;
}
var DEFAULT_CATEGORY_GAP_RATIO = 0.2;
var DEFAULT_BAR_GAP_RATIO = 0.1;
function computeValue({
  drawingArea,
  formattedSeries,
  axis: inAxis,
  extremumGetters,
  dataset,
  axisDirection,
  zoomData
}) {
  const allAxis = normalizeAxis(inAxis, dataset, axisDirection);
  const completeAxis = {};
  allAxis.forEach((axis, axisIndex) => {
    const isDefaultAxis = axisIndex === 0;
    const [minData, maxData] = getAxisExtremum(axis, extremumGetters, isDefaultAxis, formattedSeries);
    const zoom = zoomData == null ? void 0 : zoomData.find(({
      axisId
    }) => axisId === axis.id);
    const zoomRange = zoom ? [zoom.start, zoom.end] : [0, 100];
    const range = getRange(drawingArea, axisDirection, axis.reverse);
    if (isBandScaleConfig(axis)) {
      const categoryGapRatio = axis.categoryGapRatio ?? DEFAULT_CATEGORY_GAP_RATIO;
      const barGapRatio = axis.barGapRatio ?? DEFAULT_BAR_GAP_RATIO;
      const scaleRange = axisDirection === "x" ? range : [range[1], range[0]];
      const zoomedRange2 = zoomedScaleRange(scaleRange, zoomRange);
      completeAxis[axis.id] = _extends({
        categoryGapRatio,
        barGapRatio
      }, axis, {
        scale: band(axis.data, zoomedRange2).paddingInner(categoryGapRatio).paddingOuter(categoryGapRatio / 2),
        tickNumber: axis.data.length,
        colorScale: axis.colorMap && (axis.colorMap.type === "ordinal" ? getOrdinalColorScale(_extends({
          values: axis.data
        }, axis.colorMap)) : getColorScale(axis.colorMap))
      });
      if (isDateData(axis.data)) {
        const dateFormatter = createDateFormatter(axis, scaleRange);
        completeAxis[axis.id].valueFormatter = axis.valueFormatter ?? dateFormatter;
      }
    }
    if (isPointScaleConfig(axis)) {
      const scaleRange = axisDirection === "x" ? range : [...range].reverse();
      const zoomedRange2 = zoomedScaleRange(scaleRange, zoomRange);
      completeAxis[axis.id] = _extends({}, axis, {
        scale: point(axis.data, zoomedRange2),
        tickNumber: axis.data.length,
        colorScale: axis.colorMap && (axis.colorMap.type === "ordinal" ? getOrdinalColorScale(_extends({
          values: axis.data
        }, axis.colorMap)) : getColorScale(axis.colorMap))
      });
      if (isDateData(axis.data)) {
        const dateFormatter = createDateFormatter(axis, scaleRange);
        completeAxis[axis.id].valueFormatter = axis.valueFormatter ?? dateFormatter;
      }
    }
    if (axis.scaleType === "band" || axis.scaleType === "point") {
      return;
    }
    const scaleType = axis.scaleType ?? "linear";
    const extremums = [axis.min ?? minData, axis.max ?? maxData];
    const rawTickNumber = getTickNumber(_extends({}, axis, {
      range,
      domain: extremums
    }));
    const tickNumber = rawTickNumber / ((zoomRange[1] - zoomRange[0]) / 100);
    const zoomedRange = zoomedScaleRange(range, zoomRange);
    const scale = getScale(scaleType, extremums, zoomedRange).nice(rawTickNumber);
    const [minDomain, maxDomain] = scale.domain();
    const domain = [axis.min ?? minDomain, axis.max ?? maxDomain];
    completeAxis[axis.id] = _extends({}, axis, {
      scaleType,
      scale: scale.domain(domain),
      tickNumber,
      colorScale: axis.colorMap && getColorScale(axis.colorMap)
    });
  });
  return {
    axis: completeAxis,
    axisIds: allAxis.map(({
      id
    }) => id)
  };
}

// node_modules/@mui/x-charts/esm/context/CartesianProvider/CartesianProvider.js
var React9 = __toESM(require_react());

// node_modules/@mui/x-charts/esm/hooks/useSeries.js
var React7 = __toESM(require_react());

// node_modules/@mui/x-charts/esm/context/SeriesContextProvider.js
init_extends();
var React6 = __toESM(require_react());

// node_modules/@mui/x-charts/esm/internals/defaultizeColor.js
init_extends();
var DEFAULT_COLORS = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"];
function defaultizeColor(series, seriesIndex, colors = DEFAULT_COLORS) {
  if (series.type === "pie") {
    return _extends({}, series, {
      data: series.data.map((d, index) => _extends({
        color: colors[index % colors.length]
      }, d))
    });
  }
  return _extends({
    color: colors[seriesIndex % colors.length]
  }, series);
}

// node_modules/@mui/x-charts/esm/colorPalettes/colorPalettes.js
var blueberryTwilightPaletteLight = ["#02B2AF", "#2E96FF", "#B800D8", "#60009B", "#2731C8", "#03008D"];
var blueberryTwilightPaletteDark = ["#02B2AF", "#72CCFF", "#DA00FF", "#9001CB", "#2E96FF", "#3B48E0"];
var blueberryTwilightPalette = (mode) => mode === "dark" ? blueberryTwilightPaletteDark : blueberryTwilightPaletteLight;
var mangoFusionPaletteLight = ["#173A5E", "#00A3A0", "#C91B63", "#EF5350", "#FFA726", "#B800D8", "#60009B", "#2E96FF", "#2731C8", "#03008D"];
var mangoFusionPaletteDark = ["#41698F", "#19D0CD", "#DE196B", "#FC5F5C", "#FFD771", "#DA00FF", "#9001CB", "#72CCFF", "#2E96FF", "#3B48E0"];
var mangoFusionPalette = (mode) => mode === "dark" ? mangoFusionPaletteDark : mangoFusionPaletteLight;
var cheerfulFiestaPaletteDark = ["#0059B2", "#2E96FF", "#FFC24C", "#FF9F0E", "#F38200", "#2ABFDE", "#1F94AD", "#BD2C38", "#FF3143", "#FF8282"];
var cheerfulFiestaPaletteLight = ["#003A75", "#007FFF", "#FFC24C", "#FF9D09", "#CA6C00", "#127D94", "#1F94AD", "#C82634", "#FF3143", "#FF7E7E"];
var cheerfulFiestaPalette = (mode) => mode === "dark" ? cheerfulFiestaPaletteDark : cheerfulFiestaPaletteLight;

// node_modules/@mui/x-charts/esm/context/SeriesContextProvider.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var SeriesContext = React6.createContext({
  isInitialized: false,
  data: {}
});
if (true) {
  SeriesContext.displayName = "SeriesContext";
}
var preprocessSeries = (series, colors, seriesFormatters, dataset) => {
  const seriesGroups = {};
  series.forEach((seriesData, seriesIndex) => {
    var _a;
    const {
      id = `auto-generated-id-${seriesIndex}`,
      type
    } = seriesData;
    if (seriesGroups[type] === void 0) {
      seriesGroups[type] = {
        series: {},
        seriesOrder: []
      };
    }
    if (((_a = seriesGroups[type]) == null ? void 0 : _a.series[id]) !== void 0) {
      throw new Error(`MUI X: series' id "${id}" is not unique.`);
    }
    seriesGroups[type].series[id] = _extends({
      id
    }, defaultizeColor(seriesData, seriesIndex, colors));
    seriesGroups[type].seriesOrder.push(id);
  });
  const formattedSeries = {};
  Object.keys(seriesFormatters).forEach((type) => {
    var _a;
    const group = seriesGroups[type];
    if (group !== void 0) {
      formattedSeries[type] = ((_a = seriesFormatters[type]) == null ? void 0 : _a.call(seriesFormatters, group, dataset)) ?? seriesGroups[type];
    }
  });
  return formattedSeries;
};
function SeriesContextProvider(props) {
  const {
    series,
    dataset,
    colors = blueberryTwilightPalette,
    seriesFormatters,
    children
  } = props;
  const theme = useTheme();
  const formattedSeries = React6.useMemo(() => ({
    isInitialized: true,
    data: preprocessSeries(series, typeof colors === "function" ? colors(theme.palette.mode) : colors, seriesFormatters, dataset)
  }), [series, colors, theme.palette.mode, seriesFormatters, dataset]);
  return (0, import_jsx_runtime2.jsx)(SeriesContext.Provider, {
    value: formattedSeries,
    children
  });
}

// node_modules/@mui/x-charts/esm/hooks/useSeries.js
function useSeries() {
  const {
    isInitialized,
    data
  } = React7.useContext(SeriesContext);
  if (!isInitialized) {
    throw new Error(["MUI X: Could not find the series ref context.", "It looks like you rendered your component outside of a ChartsContainer parent component."].join("\n"));
  }
  return data;
}
function usePieSeries() {
  const series = useSeries();
  return React7.useMemo(() => series.pie, [series.pie]);
}
function useLineSeries() {
  const series = useSeries();
  return React7.useMemo(() => series.line, [series.line]);
}
function useBarSeries() {
  const series = useSeries();
  return React7.useMemo(() => series.bar, [series.bar]);
}
function useScatterSeries() {
  const series = useSeries();
  return React7.useMemo(() => series.scatter, [series.scatter]);
}

// node_modules/@mui/x-charts/esm/context/CartesianProvider/CartesianContext.js
var React8 = __toESM(require_react());
var CartesianContext = React8.createContext({
  isInitialized: false,
  data: {
    xAxis: {},
    yAxis: {},
    xAxisIds: [],
    yAxisIds: []
  }
});
if (true) {
  CartesianContext.displayName = "CartesianContext";
}

// node_modules/@mui/x-charts/esm/context/CartesianProvider/CartesianProvider.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
function CartesianContextProvider(props) {
  const {
    xAxis,
    yAxis,
    dataset,
    xExtremumGetters,
    yExtremumGetters,
    children
  } = props;
  const formattedSeries = useSeries();
  const drawingArea = useDrawingArea();
  const xValues = React9.useMemo(() => computeValue({
    drawingArea,
    formattedSeries,
    axis: xAxis,
    extremumGetters: xExtremumGetters,
    dataset,
    axisDirection: "x"
  }), [drawingArea, formattedSeries, xAxis, xExtremumGetters, dataset]);
  const yValues = React9.useMemo(() => computeValue({
    drawingArea,
    formattedSeries,
    axis: yAxis,
    extremumGetters: yExtremumGetters,
    dataset,
    axisDirection: "y"
  }), [drawingArea, formattedSeries, yAxis, yExtremumGetters, dataset]);
  const value = React9.useMemo(() => ({
    isInitialized: true,
    data: {
      xAxis: xValues.axis,
      yAxis: yValues.axis,
      xAxisIds: xValues.axisIds,
      yAxisIds: yValues.axisIds
    }
  }), [xValues, yValues]);
  return (0, import_jsx_runtime3.jsx)(CartesianContext.Provider, {
    value,
    children
  });
}

// node_modules/@mui/x-charts/esm/context/CartesianProvider/useCartesianContext.js
var React10 = __toESM(require_react());
var useCartesianContext = () => {
  const {
    data
  } = React10.useContext(CartesianContext);
  return data;
};

// node_modules/@mui/x-charts/esm/hooks/useAxis.js
function useXAxis(identifier) {
  const {
    xAxis,
    xAxisIds
  } = useCartesianContext();
  const id = typeof identifier === "string" ? identifier : xAxisIds[identifier ?? 0];
  return xAxis[id];
}
function useYAxis(identifier) {
  const {
    yAxis,
    yAxisIds
  } = useCartesianContext();
  const id = typeof identifier === "string" ? identifier : yAxisIds[identifier ?? 0];
  return yAxis[id];
}

// node_modules/@mui/x-charts/esm/hooks/useScale.js
function getValueToPositionMapper(scale) {
  if (isBandScale(scale)) {
    return (value) => (scale(value) ?? 0) + scale.bandwidth() / 2;
  }
  return (value) => scale(value);
}
function useXScale(identifier) {
  const axis = useXAxis(identifier);
  return axis.scale;
}
function useYScale(identifier) {
  const axis = useYAxis(identifier);
  return axis.scale;
}

// node_modules/@mui/x-charts/esm/hooks/useColorScale.js
var React12 = __toESM(require_react());

// node_modules/@mui/x-charts/esm/context/ZAxisContextProvider.js
init_extends();
var React11 = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
var ZAxisContext = React11.createContext({
  zAxis: {},
  zAxisIds: []
});
if (true) {
  ZAxisContext.displayName = "ZAxisContext";
}
function ZAxisContextProvider(props) {
  const {
    zAxis: inZAxis,
    dataset,
    children
  } = props;
  const zAxis = React11.useMemo(() => inZAxis == null ? void 0 : inZAxis.map((axisConfig) => {
    const dataKey = axisConfig.dataKey;
    if (dataKey === void 0 || axisConfig.data !== void 0) {
      return axisConfig;
    }
    if (dataset === void 0) {
      throw Error("MUI X: z-axis uses `dataKey` but no `dataset` is provided.");
    }
    return _extends({}, axisConfig, {
      data: dataset.map((d) => d[dataKey])
    });
  }), [inZAxis, dataset]);
  const value = React11.useMemo(() => {
    const allZAxis = (zAxis == null ? void 0 : zAxis.map((axis, index) => _extends({
      id: `defaultized-z-axis-${index}`
    }, axis))) ?? [];
    const completedZAxis = {};
    allZAxis.forEach((axis) => {
      completedZAxis[axis.id] = _extends({}, axis, {
        colorScale: axis.colorMap && (axis.colorMap.type === "ordinal" && axis.data ? getOrdinalColorScale(_extends({
          values: axis.data
        }, axis.colorMap)) : getColorScale(axis.colorMap.type === "continuous" ? _extends({
          min: axis.min,
          max: axis.max
        }, axis.colorMap) : axis.colorMap))
      });
    });
    return {
      zAxis: completedZAxis,
      zAxisIds: allZAxis.map(({
        id
      }) => id)
    };
  }, [zAxis]);
  return (0, import_jsx_runtime4.jsx)(ZAxisContext.Provider, {
    value,
    children
  });
}
true ? ZAxisContextProvider.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  children: import_prop_types.default.node,
  /**
   * An array of objects that can be used to populate series and axes data using their `dataKey` property.
   */
  dataset: import_prop_types.default.arrayOf(import_prop_types.default.object),
  /**
   * The configuration of the z-axes.
   */
  zAxis: import_prop_types.default.arrayOf(import_prop_types.default.shape({
    colorMap: import_prop_types.default.oneOfType([import_prop_types.default.shape({
      colors: import_prop_types.default.arrayOf(import_prop_types.default.string).isRequired,
      type: import_prop_types.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types.default.string,
      values: import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number, import_prop_types.default.string]).isRequired)
    }), import_prop_types.default.shape({
      color: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.string.isRequired), import_prop_types.default.func]).isRequired,
      max: import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number]),
      min: import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number]),
      type: import_prop_types.default.oneOf(["continuous"]).isRequired
    }), import_prop_types.default.shape({
      colors: import_prop_types.default.arrayOf(import_prop_types.default.string).isRequired,
      thresholds: import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number]).isRequired).isRequired,
      type: import_prop_types.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types.default.array,
    dataKey: import_prop_types.default.string,
    id: import_prop_types.default.string,
    max: import_prop_types.default.number,
    min: import_prop_types.default.number
  }))
} : void 0;

// node_modules/@mui/x-charts/esm/hooks/useColorScale.js
function useXColorScale(identifier) {
  const {
    xAxis,
    xAxisIds
  } = useCartesianContext();
  const id = typeof identifier === "string" ? identifier : xAxisIds[identifier ?? 0];
  return xAxis[id].colorScale;
}
function useYColorScale(identifier) {
  const {
    yAxis,
    yAxisIds
  } = useCartesianContext();
  const id = typeof identifier === "string" ? identifier : yAxisIds[identifier ?? 0];
  return yAxis[id].colorScale;
}
function useZColorScale(identifier) {
  var _a;
  const {
    zAxis,
    zAxisIds
  } = React12.useContext(ZAxisContext);
  const id = typeof identifier === "string" ? identifier : zAxisIds[identifier ?? 0];
  return (_a = zAxis[id]) == null ? void 0 : _a.colorScale;
}

// node_modules/@mui/x-charts/esm/hooks/useSvgRef.js
var React13 = __toESM(require_react());
function useSvgRef() {
  const {
    isInitialized,
    data
  } = React13.useContext(SvgContext);
  if (!isInitialized) {
    throw new Error(["MUI X: Could not find the svg ref context.", "It looks like you rendered your component outside of a ChartsContainer parent component."].join("\n"));
  }
  return data;
}

export {
  DEFAULT_X_AXIS_KEY,
  DEFAULT_Y_AXIS_KEY,
  DEFAULT_MARGINS,
  DrawingContext,
  DrawingProvider,
  blueberryTwilightPaletteLight,
  blueberryTwilightPaletteDark,
  blueberryTwilightPalette,
  mangoFusionPaletteLight,
  mangoFusionPaletteDark,
  mangoFusionPalette,
  cheerfulFiestaPaletteDark,
  cheerfulFiestaPaletteLight,
  cheerfulFiestaPalette,
  SeriesContextProvider,
  isBandScaleConfig,
  isPointScaleConfig,
  isBandScale,
  useTicks,
  getScale,
  useDrawingArea,
  useSeries,
  usePieSeries,
  useLineSeries,
  useBarSeries,
  useScatterSeries,
  CartesianContextProvider,
  useCartesianContext,
  useSvgRef,
  useChartId,
  useXAxis,
  useYAxis,
  getValueToPositionMapper,
  useXScale,
  useYScale,
  ZAxisContext,
  ZAxisContextProvider,
  useXColorScale,
  useYColorScale,
  useZColorScale
};
//# sourceMappingURL=chunk-BPYG7NHH.js.map
